# -*- coding: utf-8 -*-
"""Python_lab1CS0121.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VYHDkLEKjKvOiqmux_wUG71w6E5xIbcQ
"""



"""# Python Programming basics

## Types and Functions

Extend the function to take an optional 3rd argument.

Extend the function to take another optional flag parameter and add only if it is true
"""

def add(x, y):

    return x+y

def add(x, y, z):
  return x+y+z

def add(x, y, z, flag=True):

    #ADD YOUR CODE HERE
    result=x+y
    if flag:
      result=result+z




    return result




print(add(4,5,2))

"""Assign a function to a variable 'a' and print the output"""

def area (length,width):
  area=length*width
  return area
print(area(10,15))

"""## Iterations in python

Create a list of 5 elements

Square every item in the list using a loop inside the array index

Show how to use a iterator. First, use enumerate to create a new tuple from above list
"""

#class MyInit:
   # def __init__(self, start=25):
    #    self.current = start
   # def __iter__(self):
    #    return self

   # def __next__(self):
   #     result = self.current
    #    self.current = self.current ** 2
    #    return result

#obj1 = MyInit()


#itr = iter(obj1)


#print(next(itr))
#print(next(itr))
#print(next(itr))
def squre(x):
  return x*x

list=[1,2,4,5,6]
for i in range(5):
  print(squre(list[i]))

from typing import Tuple
#First, use enumerate to create a new tuple from above list
listSequence = ["eat","sleep","repeat"]
listSequence1=enumerate[listSequence]
print(listSequence1) #use for arrange pair keys with their values accordingly
tuple=(listSequence1)
print(tuple)

"""Now use a zip iterator to do the same.

Now state the differences between a zip and enumerate iterator.

Python`enumerate()` and `zip()` are built-in functions that can be used on sequences.

`enumerate()` function can be use to iterate over indices and items of a list.

`zip()` function make an iterator that aggregates elements from each of the iterables. In simple words it can be used to iterate over two or more lists in parallel.

## Strings in Python

Open the file poem.txt and print lenght of each line.

Find sum of each line, mean, median and standard deviation of all lines in the file.

Count the number of words in the file

Print the first 1000 characters from poem.txt.

Print the 3rd to 5th words from the file.
"""

with open('poem.txt','r') as file:

    for line in file:
      print(len(line))

word_count = 0

with open('poem.txt', 'r') as file:
    for line in file:
        words = line.split()
        word_count += len(words)

print(f"Number of words: {word_count}")

with open('poem.txt', 'r') as file:
    content = file.read(1000)

print(content)

words = []

with open('poem.txt', 'r') as file:
    for line in file:
        words.extend(line.split())


if len(words) >= 5:
    print(words[2:5])
else:
    print("Not enough words in the file.")

with open('poem.txt', 'r') as file:
    for line in file:
        words.extend(line.split())


selected_words = words[1:15][::3]

print(selected_words)

words = []

with open('poem.txt', 'r') as file:
    for line in file:
        words.extend(line.split())

if words:
    last_word = words[-1]
    if len(last_word) > 1:
        modified_word = last_word[:-2] + 'g' + last_word[-1]
        print(f"Last word (modified): {modified_word}")
    else:
        print("The last word is too short to modify.")
else:
    print("The file is empty.")



"""Get every third word between the second and the 15th words from poem.txt.

Print the last word from the file and change the second last characted in the string to 'g'.

State if the above operation completed successfully. State reasons

# Find types of Python variables and functions

Find what are the types of the following and state if they are mutable of immutable
"""

None
1
1.0
List=[1,1.0,"string"]
List.append(5)
List.append(6)
print(List)
for val in List:
  print(val)
(1,'a',3,'b')
[1,'a',3,'b']

"""Append new elements at the end of a list

Loop through each element of the list

Use a indexing operator
"""

#indexing operator
str_indexing = "hey"
str="sachin"
sum_str=str_indexing+str
print(sum_str)
lastchar=sum_str[-1]
print(lastchar)
List=[1,4,2]
Repeated_List=List*2
print(Repeated_List)
print(sum_str[3:])
firstname="rohan"
lastname="sharma"
result=lastname+3*firstname
print(result)
text = "The quick brown fox"
words = text.split()
second_word = words[1]
last_word = words[-1]
print("Second word:", second_word)
print("Last word:", last_word)
str="sachin"
n=5
num_str = str(n)
res_str=str+num_str
print(res_str)

"""Concatenate two lists

Use * to repeat lists

Use the in operator to check if something is in a list

Initialize a string and slice the first 1, 2 and 3 characters. Then from 3rd to end.

Take a first name and a last name and then concatenate the last name with 3 times the first name and show result.

Take a string with four words. Use the split function to display the second and the last words

Concatenate a number with a string. Update following:

## Dictionaries associated with lists

Create a list of keys and values
"""

x={"sachin":95,"beta":90}
print(x.keys())
print(x.values())
print(x.items())
# Convert keys view object to a list
keys_list = list(x.keys())


key1, key2 = keys_list

print(key1)  # Output: sachin
print(key2)

"""Iterate over all the keys

Iterate over all the values

Iterate over all the key-value pairs in the list

Unpack the following sequence into different variables
"""

data=('Prithwish','IIITG','prithwish.sen@iiitg','CSE')


# Unpack the tuple
name, institute, email, department = data


formatted_string = f"Name: {name}, Institute: {institute}, Email: {email}, Department: {department}"
print(formatted_string)

"""Use Python's in-built methods for string formatting"""

sales_record = {
'price': 3.24,
'num_items': 4,
'person': 'Prithwish'}
for key,value in sales_record.items():
  print(key,value)
  print('{}got {}items(s) at a cost of {}each for a total of {}'.format(key,value))

"""Take a list of 10 elements and convert into json using  json library. Demonstrate use of loads and dumps

# Python objects and functions

Take the following code:
"""

class students:
    dept = "Department of EIE"



    def assign_name(self, n):
        self.name = n

    def assign_location(self, l):
        self.location = l

    def display_info(self):
        print(f"Name: {self.name}")
        print(f"Location: {self.location}")
        print(f"Department: {self.dept}")


student1 = students()
student1.assign_name("Sachin")
student1.assign_location("Silchar")


print(f"{student1.name} lives in {student1.location} and works in the {student1.dept}.")

"""Create a object of the class above. Set name and location of your choice.

Format accordingly and print in a manner so we see something like : "Dip Sankar lives in Guwahati, Assam, India and works in the Department of CSE". The name and location should be of your choice. Use 1 print only
"""

sentence = '{sachin} lives in {silchar} and is a student in the {EIE}'
print(sentence)

"""Create two lists of 5 elements each. Map the min function to the lists using map(). Print the minimum object.

Iterate through that object and print the elements.

# Working with CSV

Let's import a file with fuel economy data
"""

import csv

with open('mpg.csv') as csvfile:
    reader = csv.reader(csvfile)

    # Read the header (first row)
    header = next(reader)
    print("Header:", header)

    # Initialize a list to store the rows
    data = []

    # Iterate through the rows and add them to the list
    for row in reader:
        data.append(row)

# Now you can work with the data list
print("\nData:")
for item in data:
    print(item)

"""Find out how many items are there in the dictionary"""

#for item in mpg[1].items():
with open('mpg.csv', 'r') as csvfile:
    reader = csv.DictReader(csvfile)  # Use DictReader for easier access to rows as dictionaries

    # Read the rows into a list
    data = [row for row in reader]

# Access the second row (index 1) and count the items in the dictionary
row_dict = data[1]  # Get the second row as a dictionary

# Count the number of items in the dictionary
count = 0
for item in row_dict.items():
    count += 1  # Increment the counter for each item

print(f"There are {count} items in the dictionary for the second row.")

"""Find the column names with keys

Find the average cty fuel economy across all cars. All values in the dictionaries are strings.

Find the average hwy fuel economy across all cars

Use set to return the unique values for the number of cylinders the cars.
"""

with open('mpg.csv', 'r') as csvfile:
    reader = csv.reader(csvfile)
    header = next(reader)
print("Column names (keys):")
print(header

total_cty = 0
count = 0
with open('mpg.csv', 'r') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        total_cty += float(row['cty'])
        count += 1
if count > 0:
    average_cty = total_cty / count
    print(f"The average city fuel economy (cty) across all cars is: {average_cty:.2f}")
else:
    print("No data available to calculate the average.")

with open('mpg.csv', 'r') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        total_hwy += float(row['hwy'])
        count += 1
if count > 0:
    average_hwy = total_hwy / count
    print(f"The average highway fuel economy (hwy) across all cars is: {average_hwy:.2f}")
else:
    print("No data available to calculate the average.")

with open('mpg.csv', 'r') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        cylinder_set.add(row['cyl'])
unique_cylinders = sorted(cylinder_set)
print("Unique number of cylinders:", unique_cylinders)

cylinders = set(d['cyl'])

"""Group the cars by number of cylinder, and finding the average cty mpg for each group."""

# Read the CSV file and store data in a list of dictionaries
with open('mpg.csv', 'r') as csvfile:
    reader = csv.DictReader(csvfile)
    mpg = [row for row in reader]

# Get unique cylinder values
cylinders = set(d['cyl'] for d in mpg)
MpgByCyl = []

for c in cylinders:  # Iterate over all the cylinder levels
    summpg = 0
    typecount = 0
    for d in mpg:  # Iterate over all dictionaries
        if d['cyl'] == c:
            summpg += float(d['cty'])  # Sum the city MPG
            typecount += 1  # Count the number of cars

    # Calculate average city MPG for this cylinder group
    if typecount > 0:
        average_cty = summpg / typecount
        MpgByCyl.append((c, average_cty))  # Append tuple of (cylinder, average MPG)

# Sort the results by cylinder count
MpgByCyl.sort(key=lambda x: int(x[0]))  # Sort by the number of cylinders

# Print the results
print("Average city MPG by number of cylinders:")
for cyl, avg_mpg in MpgByCyl:
    print(f"Cylinders: {cyl}, Average city MPG: {avg_mpg:.2f}")

"""Return the unique values for the class types in our dataset using set."""

vehicleclass = set(d['class'] for d in mpg)

"""Find average miles per gallon in the highway for each class of vehicles"""

MileageByClass = []

for t in : # iterate over all the vehicle classes
    sumpg = 0
    classCount = 0
    for d in mpg:
        if d['class'] == t:
    MileageByClass.append((t, ))

MileageByClass.sort(key=lambda x: x[1])